<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GazeBrowser ‚Äì eye controlled browsing</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }
        body {
            background: #0b1120;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 16px;
        }
        .app-container {
            max-width: 1400px;
            width: 100%;
            background: #1e293b;
            border-radius: 48px;
            padding: 24px;
            box-shadow: 0 25px 50px -12px black;
            border: 1px solid #334155;
        }
        .main-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .video-panel {
            flex: 2;
            min-width: 400px;
            position: relative;
            border-radius: 32px;
            overflow: hidden;
            background: #0f172a;
            border: 2px solid #38bdf8;
        }
        .video-container {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
        }
        #webcam {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        #overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .status-badge {
            position: absolute;
            top: 16px;
            left: 16px;
            background: #0f172ae0;
            color: white;
            padding: 8px 20px;
            border-radius: 40px;
            font-weight: 600;
            backdrop-filter: blur(4px);
            border: 1px solid #38bdf8;
            z-index: 10;
        }
        .mode-indicator {
            position: absolute;
            top: 16px;
            right: 16px;
            background: #0f172ae0;
            color: #fbbf24;
            padding: 8px 20px;
            border-radius: 40px;
            font-weight: 600;
            backdrop-filter: blur(4px);
            border: 1px solid #fbbf24;
            z-index: 10;
        }
        .control-panel {
            flex: 1;
            min-width: 280px;
            background: #1e293b;
            border-radius: 32px;
            padding: 24px;
            color: white;
            border: 1px solid #475569;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
        .section {
            background: #0f172a;
            border-radius: 24px;
            padding: 20px;
        }
        .section h3 {
            margin-bottom: 16px;
            color: #94a3b8;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .button-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        button {
            background: #2d3b4f;
            border: none;
            color: white;
            padding: 14px;
            border-radius: 40px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            border: 1px solid #60a5fa;
            box-shadow: 0 4px 0 #0f172a;
            transition: 0.08s;
        }
        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }
        .slider-container {
            margin: 16px 0;
        }
        .slider-container label {
            display: flex;
            justify-content: space-between;
            color: #cbd5e1;
        }
        input[type=range] {
            width: 100%;
            margin-top: 8px;
        }
        .scroll-area {
            background: #0f172a;
            border-radius: 16px;
            padding: 16px;
            margin-top: 24px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #475569;
            color: #e2e8f0;
        }
        .scroll-area p {
            margin: 16px 0;
            padding: 12px;
            background: #1e293b;
            border-radius: 12px;
        }
        .footer-note {
            text-align: center;
            color: #94a3b8;
            font-size: 0.9rem;
            margin-top: 16px;
        }
        #virtualCursor {
            position: fixed;
            width: 40px;
            height: 40px;
            background: white;
            border: 3px solid #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 30px cyan;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10000;
            transition: width 0.1s, height 0.1s, background 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #0f172a;
            font-weight: bold;
        }
        .click-animation {
            width: 56px !important;
            height: 56px !important;
            background: #fbbf24 !important;
            border-color: #ff8800 !important;
        }
    </style>
</head>
<body>
<div class="app-container">
    <div class="main-row">
        <!-- VIDEO PANEL -->
        <div class="video-panel">
            <div class="video-container">
                <video id="webcam" autoplay playsinline></video>
                <canvas id="overlay"></canvas>
                <div class="status-badge" id="faceStatus">‚è≥ starting camera...</div>
                <div class="mode-indicator" id="modeIndicator">‚ö´ cursor mode</div>
            </div>
        </div>

        <!-- CONTROL PANEL -->
        <div class="control-panel">
            <div class="section">
                <h3>üéØ calibration</h3>
                <div class="button-grid">
                    <button id="calibCenter">‚¨§ center</button>
                    <button id="calibLeft">‚Üê left</button>
                    <button id="calibRight">‚Üí right</button>
                    <button id="calibUp">‚Üë up</button>
                    <button id="calibDown">‚Üì down</button>
                    <button id="resetCalib">‚ü≤ reset</button>
                </div>
                <div style="margin-top: 16px; background:#1e293b; padding:12px; border-radius:30px; text-align:center;">
                    offsets: <span id="offsetDisplay">x:0.000 y:0.000</span>
                </div>
            </div>

            <div class="section">
                <h3>‚öôÔ∏è settings</h3>
                <div class="slider-container">
                    <label>cursor speed <span id="speedValue">1.8x</span></label>
                    <input type="range" id="speedSlider" min="0.5" max="3.0" step="0.1" value="1.8">
                </div>
                <div class="button-grid">
                    <button id="toggleCursor">üñ±Ô∏è enable/disable</button>
                    <button id="toggleLandmarks">üëÅÔ∏è hide overlay</button>
                </div>
            </div>

            <div class="section">
                <h3>üìú demo content (clickable & scrollable)</h3>
                <div class="scroll-area" id="scrollableDemo">
                    <p>üîµ <a href="#" onclick="alert('Link clicked!'); return false;">Click this link</a> ‚Äî blink to click.</p>
                    <p>üü¢ Paragraph 2 ‚Äì try clicking anywhere.</p>
                    <p>üü° Paragraph 3 ‚Äì scroll down to see more.</p>
                    <p>üî¥ Paragraph 4 ‚Äì use scroll mode to move this panel.</p>
                    <p>üü£ Paragraph 5 ‚Äì double blink toggles scroll mode.</p>
                    <p>‚ö™ Paragraph 6 ‚Äì then look up/down to scroll.</p>
                    <p>üü§ Paragraph 7 ‚Äì the virtual cursor clicks elements.</p>
                    <p>üîµ Paragraph 8 ‚Äì everything happens on this page.</p>
                </div>
            </div>

            <div class="footer-note">
                üîí camera data never leaves your device. <br>
                üí° single blink = click ¬∑ double blink = toggle scroll mode
            </div>
        </div>
    </div>
</div>

<div id="virtualCursor">‚ö°</div>

<script>
(function() {
    // ----- DOM elements -----
    const video = document.getElementById('webcam');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const cursorDiv = document.getElementById('virtualCursor');
    const faceStatus = document.getElementById('faceStatus');
    const modeIndicator = document.getElementById('modeIndicator');
    const offsetDisplay = document.getElementById('offsetDisplay');
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');

    // Buttons
    const calibCenter = document.getElementById('calibCenter');
    const calibLeft = document.getElementById('calibLeft');
    const calibRight = document.getElementById('calibRight');
    const calibUp = document.getElementById('calibUp');
    const calibDown = document.getElementById('calibDown');
    const resetCalib = document.getElementById('resetCalib');
    const toggleCursor = document.getElementById('toggleCursor');
    const toggleLandmarks = document.getElementById('toggleLandmarks');

    // ----- state -----
    let faceMesh = null;
    let landmarks = null;
    let cursorEnabled = true;
    let drawOverlay = true;
    let scrollMode = false; // false = cursor mode, true = scroll mode

    // calibration offsets (added to raw gaze)
    let offsetX = 0.0, offsetY = 0.0;

    // vertical compensation (camera above eyes)
    const VERTICAL_COMP = 0.15;

    // speed multiplier
    let speed = 1.8; // matches slider default

    // smoothing
    const historyX = [], historyY = [];
    const SMOOTH_FRAMES = 5;

    // blink detection
    const EAR_THRESHOLD = 0.23;
    const BLINK_FRAMES = 2;
    let blinkCounter = 0;
    let blinkCooldown = 0;
    let doubleBlinkWindow = [];
    const DOUBLE_BLINK_MS = 400;

    // eye landmark indices
    const LEFT_IRIS = 468;
    const RIGHT_IRIS = 473;
    const LEFT_EYE = [33, 133, 159, 145];
    const RIGHT_EYE = [362, 263, 386, 374];

    // ----- helpers -----
    function log(msg) { console.log(msg); } // keep console clean

    function eyeAspectRatio(landmarks, idxs) {
        try {
            const p1 = landmarks[idxs[0]], p2 = landmarks[idxs[1]], p3 = landmarks[idxs[2]], p4 = landmarks[idxs[3]];
            const width = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const height = Math.hypot(p4.x - p3.x, p4.y - p3.y);
            return width > 0 ? height / width : 1.0;
        } catch { return 1.0; }
    }

    function updateOffsetDisplay() {
        offsetDisplay.innerText = `x:${offsetX.toFixed(3)} y:${offsetY.toFixed(3)}`;
    }

    // ----- face detection setup -----
    async function init() {
        try {
            faceStatus.innerText = 'üì∑ requesting camera...';
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: 'user' } });
            video.srcObject = stream;
            await video.play();
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
            faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            faceMesh.onResults(onFaceResults);

            faceStatus.innerText = 'üëÄ looking for face...';
            detectLoop();
        } catch (err) {
            faceStatus.innerText = '‚ùå camera error';
            alert('Camera access failed: ' + err.message);
        }
    }

    async function detectLoop() {
        if (faceMesh && video.readyState >= 2) {
            await faceMesh.send({ image: video });
        }
        requestAnimationFrame(detectLoop);
    }

    function onFaceResults(results) {
        if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
            faceStatus.innerText = 'üò¥ no face';
            landmarks = null;
            if (!drawOverlay) ctx.clearRect(0,0,canvas.width,canvas.height);
            return;
        }
        faceStatus.innerText = '‚úÖ face detected';
        const lm = results.multiFaceLandmarks[0];
        landmarks = [];
        for (let i=0; i<lm.length; i++) landmarks.push({ x: lm[i].x, y: lm[i].y, z: lm[i].z });

        if (drawOverlay) drawLandmarks(landmarks);
        else ctx.clearRect(0,0,canvas.width,canvas.height);

        processGazeAndBlink(landmarks);
    }

    function drawLandmarks(lm) {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        // eye contours
        ctx.beginPath();
        for (let i=33; i<=133; i+=10) if(lm[i]) ctx.lineTo(lm[i].x*canvas.width, lm[i].y*canvas.height);
        ctx.stroke();
        ctx.beginPath();
        for (let i=362; i<=463; i+=10) if(lm[i]) ctx.lineTo(lm[i].x*canvas.width, lm[i].y*canvas.height);
        ctx.stroke();
        // irises
        ctx.fillStyle = '#ffaa00';
        if(lm[LEFT_IRIS]) ctx.arc(lm[LEFT_IRIS].x*canvas.width, lm[LEFT_IRIS].y*canvas.height, 5,0,2*Math.PI) && ctx.fill();
        if(lm[RIGHT_IRIS]) ctx.beginPath() && ctx.arc(lm[RIGHT_IRIS].x*canvas.width, lm[RIGHT_IRIS].y*canvas.height, 5,0,2*Math.PI) && ctx.fill();
    }

    function processGazeAndBlink(lm) {
        if (!cursorEnabled) {
            cursorDiv.style.opacity = '0.3';
            return;
        } else cursorDiv.style.opacity = '1';

        const leftIris = lm[LEFT_IRIS], rightIris = lm[RIGHT_IRIS];
        if (!leftIris || !rightIris) return;

        // raw gaze (0-1)
        let rawX = (leftIris.x + rightIris.x) / 2;
        let rawY = (leftIris.y + rightIris.y) / 2;

        // apply calibration and vertical compensation
        let gazeX = rawX + offsetX;
        let gazeY = rawY + offsetY + VERTICAL_COMP;
        gazeX = Math.min(1, Math.max(0, gazeX));
        gazeY = Math.min(1, Math.max(0, gazeY));

        // apply speed: map from center (0.5) with multiplier
        // first shift to -0.5..0.5 range, multiply, then shift back
        let centeredX = (gazeX - 0.5) * speed;
        let centeredY = (gazeY - 0.5) * speed;
        // clamp again after speed
        gazeX = Math.min(1, Math.max(0, 0.5 + centeredX));
        gazeY = Math.min(1, Math.max(0, 0.5 + centeredY));

        // smoothing
        historyX.push(gazeX);
        historyY.push(gazeY);
        if (historyX.length > SMOOTH_FRAMES) historyX.shift();
        if (historyY.length > SMOOTH_FRAMES) historyY.shift();
        const smoothX = historyX.reduce((a,b)=>a+b,0)/historyX.length;
        const smoothY = historyY.reduce((a,b)=>a+b,0)/historyY.length;

        if (scrollMode) {
            // scroll mode: vertical movement scrolls the demo area
            const demoDiv = document.getElementById('scrollableDemo');
            const scrollDelta = (smoothY - 0.5) * 10; // intensity
            demoDiv.scrollTop += scrollDelta;
            modeIndicator.innerText = 'üîΩ scroll mode';
        } else {
            // cursor mode: move virtual cursor
            const screenX = smoothX * window.innerWidth;
            const screenY = smoothY * window.innerHeight;
            cursorDiv.style.left = screenX + 'px';
            cursorDiv.style.top = screenY + 'px';
            modeIndicator.innerText = '‚ö´ cursor mode';
        }

        // blink detection
        const leftEAR = eyeAspectRatio(lm, LEFT_EYE);
        const rightEAR = eyeAspectRatio(lm, RIGHT_EYE);
        const ear = (leftEAR + rightEAR) / 2;

        if (blinkCooldown > 0) {
            blinkCooldown--;
            return;
        }

        if (ear < EAR_THRESHOLD) {
            blinkCounter++;
            if (blinkCounter >= BLINK_FRAMES) {
                blinkCounter = 0;
                blinkCooldown = 8;

                const now = Date.now();
                doubleBlinkWindow.push(now);
                doubleBlinkWindow = doubleBlinkWindow.filter(t => now - t < DOUBLE_BLINK_MS);

                if (doubleBlinkWindow.length >= 2) {
                    // double blink: toggle scroll mode
                    scrollMode = !scrollMode;
                    doubleBlinkWindow = [];
                    cursorDiv.classList.add('click-animation');
                    setTimeout(() => cursorDiv.classList.remove('click-animation'), 200);
                } else {
                    // single blink: perform click (only if in cursor mode)
                    if (!scrollMode && cursorEnabled) {
                        // get element under cursor and click it
                        const cursorRect = cursorDiv.getBoundingClientRect();
                        const elem = document.elementFromPoint(cursorRect.left + cursorRect.width/2, cursorRect.top + cursorRect.height/2);
                        if (elem) {
                            elem.click();
                            // also trigger a focus for input fields? not needed for demo
                        }
                        cursorDiv.classList.add('click-animation');
                        setTimeout(() => cursorDiv.classList.remove('click-animation'), 200);
                    }
                }
            }
        } else {
            blinkCounter = 0;
        }
    }

    // ----- calibration -----
    function setOffset(targetX, targetY) {
        if (!landmarks) { alert('No face detected'); return; }
        const leftIris = landmarks[LEFT_IRIS], rightIris = landmarks[RIGHT_IRIS];
        if (!leftIris || !rightIris) { alert('Iris not visible'); return; }
        let rawX = (leftIris.x + rightIris.x) / 2;
        let rawY = (leftIris.y + rightIris.y) / 2;
        // we want: raw + offset + VERT_COMP = target
        // so offset = target - raw - VERT_COMP
        offsetX = targetX - rawX;
        offsetY = targetY - rawY - VERTICAL_COMP;
        updateOffsetDisplay();
    }

    function resetOffsets() {
        offsetX = 0; offsetY = 0;
        updateOffsetDisplay();
    }

    // ----- event listeners -----
    calibCenter.addEventListener('click', () => setOffset(0.5, 0.5));
    calibLeft.addEventListener('click', () => setOffset(0.2, 0.5));
    calibRight.addEventListener('click', () => setOffset(0.8, 0.5));
    calibUp.addEventListener('click', () => setOffset(0.5, 0.2));
    calibDown.addEventListener('click', () => setOffset(0.5, 0.8));
    resetCalib.addEventListener('click', resetOffsets);

    toggleCursor.addEventListener('click', () => {
        cursorEnabled = !cursorEnabled;
        toggleCursor.innerText = cursorEnabled ? 'üñ±Ô∏è disable cursor' : 'üñ±Ô∏è enable cursor';
    });

    toggleLandmarks.addEventListener('click', () => {
        drawOverlay = !drawOverlay;
        toggleLandmarks.innerText = drawOverlay ? 'üëÅÔ∏è hide overlay' : 'üëÅÔ∏è show overlay';
        if (!drawOverlay) ctx.clearRect(0,0,canvas.width,canvas.height);
    });

    speedSlider.addEventListener('input', (e) => {
        speed = parseFloat(e.target.value);
        speedValue.innerText = speed.toFixed(1) + 'x';
    });

    // initialize
    init();
    updateOffsetDisplay();

    // extra: allow clicking on the demo area by actually simulating click above
    // the virtual cursor click already does that
})();
</script>
</body>
</html>
